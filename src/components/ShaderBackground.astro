---
---

<canvas id="shader-canvas"></canvas>

<script>
	const canvas = document.getElementById("shader-canvas") as HTMLCanvasElement;
	const gl = canvas.getContext("webgl");

	if (gl) {
		const targetFps = 30;
		const frameInterval = 1000 / targetFps;
		let animationId: number;
		let startTime = performance.now();
		let lastFrameTime = 0;

		const vertSrc = `
			attribute vec2 a_position;
			void main() {
				gl_Position = vec4(a_position, 0.0, 1.0);
			}
		`;

		const fragSrc = `
			precision highp float;
			uniform vec2 u_resolution;
			uniform float u_time;

			vec4 tanh4(vec4 x) {
				vec4 e2x = exp(2.0 * x);
				return (e2x - 1.0) / (e2x + 1.0);
			}

			void main() {
				vec4 o = vec4(0.0);
				vec2 FC = gl_FragCoord.xy;
				vec2 r = u_resolution;
				float t = u_time;

				vec3 p;
				float d, z;

				vec2 uv = FC.xy * 2.0;

				for(float i = 0.0; i < 20.0; i++) {
					p = z * normalize(vec3(uv, r.y));
					p.z -= t - z * 1.6;
					d = abs(0.03 * z - 0.3);
					p = cos(p);
					d = max(d, length(max(p, p.yzx)) - d);
					z += d;
					o += (cos(z * 0.3 + vec4(2.5, 0.8, 0.4, 0.0)) + 2.0) / d / z;
				}

				o = tanh4(o * o / 900.0) * 0.5;
				gl_FragColor = o;
			}
		`;

		function createShader(type: number, source: string): WebGLShader | null {
			const shader = gl!.createShader(type);
			if (!shader) return null;
			gl!.shaderSource(shader, source);
			gl!.compileShader(shader);
			if (!gl!.getShaderParameter(shader, gl!.COMPILE_STATUS)) {
				gl!.deleteShader(shader);
				return null;
			}
			return shader;
		}

		const vs = createShader(gl.VERTEX_SHADER, vertSrc);
		const fs = createShader(gl.FRAGMENT_SHADER, fragSrc);

		if (vs && fs) {
			const program = gl.createProgram()!;
			gl.attachShader(program, vs);
			gl.attachShader(program, fs);
			gl.linkProgram(program);

			if (gl.getProgramParameter(program, gl.LINK_STATUS)) {
				const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
				const buffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
				gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

				const posLoc = gl.getAttribLocation(program, "a_position");
				gl.enableVertexAttribArray(posLoc);
				gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

				const resLoc = gl.getUniformLocation(program, "u_resolution");
				const timeLoc = gl.getUniformLocation(program, "u_time");

				function resize() {
					const dpr = (window.devicePixelRatio || 1) * 0.5;
					canvas.width = canvas.clientWidth * dpr;
					canvas.height = canvas.clientHeight * dpr;
					gl!.viewport(0, 0, canvas.width, canvas.height);
				}

				function render(time: number) {
					animationId = requestAnimationFrame(render);
					const delta = time - lastFrameTime;
					if (delta < frameInterval) return;
					lastFrameTime = time - (delta % frameInterval);

					const elapsed = (time - startTime) / 1000 * 0.1;
					gl!.useProgram(program);
					gl!.uniform2f(resLoc, canvas.width, canvas.height);
					gl!.uniform1f(timeLoc, elapsed);
					gl!.drawArrays(gl!.TRIANGLE_STRIP, 0, 4);
				}

				resize();
				animationId = requestAnimationFrame(render);
				window.addEventListener("resize", resize);

				document.addEventListener("visibilitychange", () => {
					if (document.hidden) {
						cancelAnimationFrame(animationId);
					} else {
						lastFrameTime = 0;
						animationId = requestAnimationFrame(render);
					}
				});
			}
		}
	}
</script>

<style>
	#shader-canvas {
		position: fixed;
		inset: 0;
		width: 100%;
		height: 100%;
		z-index: -1;
		pointer-events: none;
	}
</style>
